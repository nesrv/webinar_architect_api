## Что такое gRPC?

**gRPC** - это современная система удаленного вызова процедур (RPC), разработанная Google. Представьте, что у вас есть функция на одном компьютере, а вызвать её нужно с другого компьютера через интернет - именно для этого и нужен gRPC.

### Основные преимущества gRPC:

- **Быстрый** - использует бинарный протокол (Protocol Buffers)
- **Типизированный** - строгие типы данных, как в обычном программировании
- **Поддерживает потоки** - может отправлять много сообщений подряд
- **Кроссплатформенный** - работает на разных языках программирования

## Структура проекта

```
m7/ex-1/
├── todo.proto          # Описание API (контракт)
├── todo_pb2.py         # Сгенерированные классы сообщений
├── todo_pb2_grpc.py    # Сгенерированные gRPC классы
├── server.py           # Сервер (обрабатывает запросы)
└── client.py           # Клиент (отправляет запросы)
```

## Пошаговое объяснение

### 1. Файл todo.proto - "Контракт" API

```protobuf
syntax = "proto3";

service TodoService {
  rpc AddTask (TaskRequest) returns (TaskResponse);
  rpc GetTasks (GetTasksRequest) returns (stream TaskResponse);
}
```

**Что это значит:**

- `service TodoService` - создаем сервис с именем "TodoService"
- `rpc AddTask` - метод для добавления задачи (как обычная функция)
- `TaskRequest` - что отправляем (входные данные)
- `TaskResponse` - что получаем обратно (результат)
- `stream TaskResponse` - получаем много ответов подряд (поток данных)

**Сообщения (структуры данных):**

```protobuf
message TaskRequest {
  string title = 1;        // Название задачи
  string description = 2;  // Описание задачи
}

message TaskResponse {
  int32 id = 1;           // Уникальный номер задачи
  string title = 2;       // Название
  string description = 3; // Описание
  bool completed = 4;     // Выполнена ли задача
}
```

**Аналогия:** Это как техническое задание для программиста - точно описывает, что должен делать сервис и какие данные принимать/возвращать.

### 2. Сервер (server.py) - "Исполнитель"

```python
class TodoService(todo_pb2_grpc.TodoServiceServicer):
    def __init__(self):
        self.tasks = []      # Список задач в памяти
        self.next_id = 1     # Счетчик для ID задач
```

**Что происходит:**

- Создаем класс, который реализует наш сервис
- `self.tasks = []` - простой список для хранения задач (в реальности была бы база данных)
- `self.next_id = 1` - счетчик для присвоения уникальных номеров задачам

**Метод добавления задачи:**

```python
def AddTask(self, request, context):
    task = todo_pb2.TaskResponse(
        id=self.next_id,
        title=request.title,           # Берем из запроса
        description=request.description, # Берем из запроса
        completed=False                # По умолчанию не выполнена
    )
    self.tasks.append(task)  # Добавляем в список
    self.next_id += 1        # Увеличиваем счетчик
    return task              # Возвращаем созданную задачу
```

**Метод получения всех задач:**

```python
def GetTasks(self, request, context):
    for task in self.tasks:
        yield task  # Отправляем задачи по одной через поток
```

**Аналогия:** Сервер - это как официант в ресторане. Клиент заказывает блюдо (отправляет запрос), официант передает заказ на кухню (обрабатывает запрос) и приносит готовое блюдо (возвращает ответ).

### 3. Клиент (client.py) - "Заказчик"

```python
def run():
    # Подключаемся к серверу
    channel = grpc.insecure_channel('localhost:50051')
    stub = todo_pb2_grpc.TodoServiceStub(channel)
```

**Что происходит:**

- `channel` - это "телефонная линия" к серверу
- `stub` - это "пульт управления" с кнопками для вызова методов сервера

**Добавление задачи:**

```python
response = stub.AddTask(todo_pb2.TaskRequest(
    title="Изучить gRPC",
    description="Практическое занятие"
))
print(f"Добавлена задача: {response.title} (ID: {response.id})")
```

**Получение всех задач:**

```python
for task in stub.GetTasks(todo_pb2.GetTasksRequest()):
    print(f"- {task.title} (Выполнено: {task.completed})")
```

**Аналогия:** Клиент - это как посетитель ресторана. Он смотрит меню (proto файл), делает заказ (отправляет запрос) и получает блюдо (получает ответ).

## Как это работает пошагово

### Шаг 1: Генерация кода

```bash
python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. todo.proto
```

Эта команда читает `todo.proto` и создает Python файлы с классами.

### Шаг 2: Запуск сервера

```bash
python server.py
```

Сервер начинает "слушать" порт 50051 и ждать запросы.

### Шаг 3: Запуск клиента

```bash
python client.py
```

Клиент подключается к серверу и отправляет запросы.

## Типы взаимодействия в этом примере

### 1. Унарный RPC (AddTask)

```
Клиент ----[один запрос]----> Сервер
Клиент <---[один ответ]------ Сервер
```

Как обычный вызов функции: отправил данные, получил результат.

### 2. Серверный поток (GetTasks)

```
Клиент ----[один запрос]----> Сервер
Клиент <---[ответ 1]--------- Сервер
Клиент <---[ответ 2]--------- Сервер
Клиент <---[ответ 3]--------- Сервер
```

Клиент просит список, сервер отправляет элементы по одному.

## Практическое применение

**Где используется gRPC:**

- Микросервисы (сервисы общаются между собой)
- Мобильные приложения (быстрая связь с сервером)
- IoT устройства (эффективная передача данных)
- Высоконагруженные системы (Google, Netflix, Uber)

## Запуск примера

1. **Установите зависимости:**

```bash
pip install grpcio grpcio-tools
```

2. **Сгенерируйте код (если нужно):**

```bash
python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. todo.proto
```

3. **Запустите сервер:**

```bash
python server.py
```

4. **В другом терминале запустите клиент:**

```bash
python client.py
```

## Что увидите в результате

```
Добавлена задача: Изучить gRPC (ID: 1)

Все задачи:
- Изучить gRPC (Выполнено: False)
```

## Следующие шаги

После понимания этого примера можно:

1. Добавить больше методов (удаление, обновление задач)
2. Изучить клиентские потоки
3. Изучить двунаправленные потоки
4. Добавить обработку ошибок
5. Изучить аутентификацию в gRPC

**Главное:** gRPC делает вызов удаленных функций таким же простым, как вызов локальных функций, но с дополнительными возможностями для работы с потоками данных.
